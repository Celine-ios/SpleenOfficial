## mysqli_result::fetch_array

mysqli_fetch_array

(PHP 5, PHP 7)
mysqli_result::fetch_array -- mysqli_fetch_array — Obtiene una fila de resultados como un array asociativo, numérico, o ambos

Descripción ¶

Estilo orientado a objetos

mixed mysqli_result::fetch_array ([ int $resulttype = MYSQLI_BOTH ] )
Estilo por procedimientos

mixed mysqli_fetch_array ( mysqli_result $result [, int $resulttype = MYSQLI_BOTH ] )
Retorna un array que corresponde a la fila obtenida o NULL si es que no hay más filas en el resultset representado por el parámetro result.

mysqli_fetch_array() es una versión extendida de la función mysqli_fetch_row(). Además de guardar la información en los índices numéricos del array resultante, la función mysqli_fetch_array() también puede guardar la información en índices asociativos, utilizando los nombres de los campos del resultado como llaves.

Nota: Los nombres de los campos devueltos por esta función son sensibles a mayúsculas y minúsculas.
Nota: Esta función define campos NULOS al valor NULL de PHP.
Si dos o más columnas del resultado tienen el mismo nombre de campo, la última columna tomará precedencia y sobrescribirá la información anterior. Para acceder a múltiples columnas con el mismo nombre, hay que usar la versión numéricamente indexada de la fila.

Parámetros ¶

result
Sólo estilo por procedimientos: Un conjunto de identificadores de resultados devuelto por mysqli_query(), mysqli_store_result() o mysqli_use_result().

resulttype
Este parámetro opcional es una constante que indica qué tipo de array debiera generarse con la información de la fila actual. Los valores posibles para este parámetro son las constantes MYSQLI_ASSOC, MYSQLI_NUM, o MYSQLI_BOTH.

Al emplear la constante MYSQLI_ASSOC esta función se comportará de manera idéntica a mysqli_fetch_assoc(), mientras que con MYSQLI_NUM se comportará exactamente igual que la función mysqli_fetch_row(). La última opción MYSQLI_BOTH creará un único array con los atributos de ambas dos.

Valores devueltos ¶

Retorna un array de strings que corresponde a la fila obtenida o NULL si no hay más filas en el resultset.

Ejemplos ¶

Ejemplo #1 Estilo orientado a objetos

<?php
$mysqli = new mysqli("localhost", "my_user", "my_password", "world");

/* verificar la conexión */
if (mysqli_connect_errno()) {
    printf("Falló la conexión failed: %s\n", $mysqli->connect_error);
    exit();
}

$query = "SELECT Name, CountryCode FROM City ORDER by ID LIMIT 3";
$result = $mysqli->query($query);

/* array numérico */
$row = $result->fetch_array(MYSQLI_NUM);
printf ("%s (%s)\n", $row[0], $row[1]);

/* array asociativo */
$row = $result->fetch_array(MYSQLI_ASSOC);
printf ("%s (%s)\n", $row["Name"], $row["CountryCode"]);

/* array numérico y asociativo */
$row = $result->fetch_array(MYSQLI_BOTH);
printf ("%s (%s)\n", $row[0], $row["CountryCode"]);

/* liberar la serie de resultados */
$result->free();

/* cerrar la conexión */
$mysqli->close();
?>
Ejemplo #2 Estilo por procedimientos

<?php
$link = mysqli_connect("localhost", "my_user", "my_password", "world");

/* verificar la conexión */
if (mysqli_connect_errno()) {
    printf("Conexión fallida: %s\n", mysqli_connect_error());
    exit();
}

$query = "SELECT Name, CountryCode FROM City ORDER by ID LIMIT 3";
$result = mysqli_query($link, $query);

/* array numérico */
$row = mysqli_fetch_array($result, MYSQLI_NUM);
printf ("%s (%s)\n", $row[0], $row[1]);

/* array asociativo */
$row = mysqli_fetch_array($result, MYSQLI_ASSOC);
printf ("%s (%s)\n", $row["Name"], $row["CountryCode"]);

/* array numérico y asociativo */
$row = mysqli_fetch_array($result, MYSQLI_BOTH);
printf ("%s (%s)\n", $row[0], $row["CountryCode"]);

/* liberar la serie de resultados */
mysqli_free_result($result);

/* cerrar la conexión */
mysqli_close($link);
?>
El resultado de los ejemplos sería:

Kabul (AFG)
Qandahar (AFG)
Herat (AFG)
Ver también ¶

mysqli_fetch_assoc() - Obtener una fila de resultado como un array asociativo
mysqli_fetch_row() - Obtener una fila de resultados como un array enumerado
mysqli_fetch_object() - Devuelve la fila actual de un conjunto de resultados como un objeto
mysqli_query() - Realiza una consulta a la base de datos
mysqli_data_seek() - Ajustar el puntero de resultado a una fila arbitraria del resultado
add a note add a note
User Contributed Notes 4 notes

up
down
62 Jammerx2 ¶7 years ago
Putting multiple rows into an array:

<?php
$mysqli = new mysqli("localhost", "my_user", "my_password", "world");

/* check connection */
if (mysqli_connect_errno()) {
    printf("Connect failed: %s\n", mysqli_connect_error());
    exit();
}

$query = "SELECT Name, CountryCode FROM City ORDER by ID LIMIT 3";
$result = $mysqli->query($query);

while($row = $result->fetch_array())
{
$rows[] = $row;
}

foreach($rows as $row)
{
echo $row['CountryCode'];
}

/* free result set */
$result->close();

/* close connection */
$mysqli->close();
?>
up
down
4 Duncan ¶4 years ago
Note that the array returned contains only strings.

E.g. when a MySQL field is an INT you may expect the field to be returned as an integer, however all fields are simply returned as strings.

What this means: use double-equals not triple equals when comparing numbers.

<?php
print $array_from_mysqli_fetch_array['id'] == 1 ? "true" : "false"; // true
print $array_from_mysqli_fetch_array['id'] === 1 ? "true" : "false"; // false
?>
up
down
1 meaje at msn dot com ¶1 month ago
Please note that under PHP 5.x there appears to be a globally defined variable MYSQL_ASSOC, MYSQL_NUM, or MYSQL_BOTH which is the equivalent of MYSQLI_ASSOC, MYSQLI_NUM, or MYSQLI_BOTH!!! Yet under PHP 7.x this is NOT the case and will cause a failure in trying to retrieve the result set!

This can cause severe headaches when trying to find out why you are getting the error: 
- mysqli_result::fetch_array() expects parameter 1 to be integer, string given in 'Filename' on line 'XX'
up
down
-26 ahouston at gmail dot com ¶6 years ago
Here is a function to return an associative array with multiple columns as keys to the array.

This is a rough approximation of the perl DBI->fetchall_hashref function - something I find myself using quite a bit.

Given a simple mySQL table:

mysql> select * from city;
+----------------+----------------+------------------+------------+
| country        | region         | city             | hemisphere |
+----------------+----------------+------------------+------------+
| South Africa   | KwaZulu-Natal  | Durban           | South      |
| South Africa   | Gauteng        | Johannesburg     | South      |
| South Africa   | Gauteng        | Tshwane          | South      |
| South Africa   | KwaZulu-Natal  | Pietermaritzburg | South      |
| United Kingdom | Greater London | City of London   | North      |
| United Kingdom | Greater London | Wimbledon        | North      |
| United Kingdom | Lancashire     | Liverpool        | North      |
| United Kingdom | Lancashire     | Manchester       | North      |
+----------------+----------------+------------------+------------+

*Note* - this is a simple function that makes no attempt to keep multiple values per key, so you need to specify all the unique keys you require.

<?php

        $link = mysqli_connect("localhost", "username", "password", "test");
        $result = mysqli_query($link, "select * from city");
        $results_arr = fetch_all_assoc($result,array('hemisphere','country','region','city'));

function fetch_all_assoc(& $result,$index_keys) {

  // Args :    $result = mysqli result variable (passed as reference to allow a free() at the end
  //           $indexkeys = array of columns to index on
  // Returns : associative array indexed by the keys array

  $assoc = array();             // The array we're going to be returning

  while ($row = mysqli_fetch_array($result, MYSQLI_ASSOC)) {

        $pointer = & $assoc;            // Start the pointer off at the base of the array

        for ($i=0; $i<count($index_keys); $i++) {
        
                $key_name = $index_keys[$i];
                if (!isset($row[$key_name])) {
                        print "Error: Key $key_name is not present in the results output.\n";
                        return(false);
                }

                $key_val= isset($row[$key_name]) ? $row[$key_name]  : "";
        
                if (!isset($pointer[$key_val])) {               

                        $pointer[$key_val] = "";                // Start a new node
                        $pointer = & $pointer[$key_val];                // Move the pointer on to the new node
                }
                else {
                        $pointer = & $pointer[$key_val];            // Already exists, move the pointer on to the new node
                }

        } // for $i

        // At this point, $pointer should be at the furthest point on the tree of keys
        // Now we can go through all the columns and place their values on the tree
        // For ease of use, include the index keys and their values at this point too

        foreach ($row as $key => $val) {
                        $pointer[$key] = $val;
        }

  } // $row

  /* free result set */
  $result->close();

  return($assoc);               
}

?>